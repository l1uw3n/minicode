<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>未知 </title></head><body>
<h1 id="_1">链码说明</h1>
<p><em>[注]以下所有函数的返回值均为字节数组. 需转换为字符串后再进行返回值解析.</em></p>
<h2 id="_2">链上对象</h2>
<p><img alt="bcobj" src="./bcobj.png" /></p>
<h2 id="_3">链码函数</h2>
<h3 id="_4">初始化</h3>
<ul>
<li>
<p>调用函数: <strong>init</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>链码初始化函数, 仅可在链码实例化和升级时自动调用, 目前无需参数传递</p>
</blockquote>
<ul>
<li>
<p>函数参数:</p>
</li>
<li>
<p>请求示例:</p>
</li>
<li>
<p>命令行:
  <code>bash
  peer chaincode instantiate -n example -v 1 -c '{"Args":["init"]}' -C mych -P   "AND ('Org1MSP.member')"</code></p>
</li>
</ul>
<h3 id="_5">用户初始化</h3>
<ul>
<li>
<p>调用函数: <strong>userInit</strong></p>
</li>
<li>
<p>函数说明: </p>
</li>
</ul>
<blockquote>
<p>对用户进行链上初始化, 未初始化的用户不可对区块链进行其他请求. 初始化无需额外参数, 用户信息将从用户证书中读取.</p>
</blockquote>
<ul>
<li>
<p>函数参数:</p>
</li>
<li>
<p>请求示例:</p>
</li>
<li>
<p>命令行:
  <code>bash
  peer chaincode invoke -C mych -n example -c '{"Args":["userInit"]}'</code></p>
</li>
<li>SDK(go):
  <code>go
  req := channel.Request{ChaincodeID: "mych", Fcn: "userInit", Args: nil}
  respone, err := t.Client.Execute(req)</code></li>
</ul>
<h3 id="_6">资源上传</h3>
<ul>
<li>
<p>调用函数: <strong>assetUpload</strong></p>
</li>
<li>
<p>函数说明: </p>
</li>
</ul>
<blockquote>
<p>为用户提供资源上传入链的接口. 用户上传资源后自动与用户账号绑定. 资源哈希既作为链上快速查询的key, 又可作为校验资源其他相关外部数据真实性的hash码. 资源外部链接用于定位资源实际存储位置. 资源价值表示资源交易产生的价值转移.</p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>assetHash</td>
<td>string</td>
<td>资源哈希, 唯一确定资源</td>
<td>不可空</td>
</tr>
<tr>
<td>assetLink</td>
<td>string</td>
<td>资源外部链接</td>
<td>不可空</td>
</tr>
<tr>
<td>assetPerm</td>
<td>string</td>
<td>资源权限</td>
<td>可空</td>
</tr>
<tr>
<td>assetPlist</td>
<td>string</td>
<td>资源白名单/黑名单</td>
<td>可空</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>请求示例:</p>
</li>
<li>
<p>命令行:
  <code>bash
  peer chaincode invoke -C mych -n example -c '{"Args":["assetUpload", "03a471b6c3d2...", "url...", "-1,-1,300,100,0", "ebg.ebtech.oms:true, ebg.ebtech:false"]}'</code></p>
</li>
<li>SDK(go):
  <code>go
  assetHash := "03a471b6c3d2..."
  assetLink := "url..."
  assetPerm := ""
  assetPlist := ""
  req := channel.Request{ChaincodeID: "mych", Fcn: "assetUpload", Args: [][]byte{[]byte(assetHash), []byte(assetLink), []byte(assetPerm), []byte(assetPlist)}}
  respone, err := t.Client.Execute(req)</code></li>
</ul>
<h3 id="_7">资源购买</h3>
<ul>
<li>
<p>函数调用: <strong>assetBuy</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>为用户提供资源购买的接口. 资源购买不涉及所有权转移, 只是将资源标记为已拥有状态, 并扣除购买者于资源等值的积分余额, 同时为资源所有者(上传者)增加相同的积分余额.</p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>assetHash</td>
<td>string</td>
<td>要购买的资源哈希</td>
<td>不可空</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>请求示例:</p>
</li>
<li>
<p>命令行:
  <code>bash
  peer chaincode invoke -C mych -n example -c '{"Args":["assetBuy", "03a471b6c3d2..."]}'</code></p>
</li>
<li>SDK(go):
  <code>go
  assetHash := "03a471b6c3d2..."
  req := channel.Request{ChaincodeID: "mych", Fcn: "assetBuy", Args: [][]byte{[]byte(assetHash)}}
  respone, err := t.Client.Execute(req)</code></li>
</ul>
<h3 id="_8">资源浏览/上传次数统计</h3>
<ul>
<li>
<p>函数调用: <strong>assetTimesCount</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>为用户提供资源浏览/上传次数统计的接口. </p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>assetHash</td>
<td>string</td>
<td>要计数的资源哈希</td>
<td>不可空</td>
</tr>
<tr>
<td>countType</td>
<td>string</td>
<td>计数类型(view: 浏览; download: 下载)</td>
<td>不可空</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>请求示例:</p>
</li>
<li>
<p>命令行:
  <code>bash
  peer chaincode invoke -C mych -n example -c '{"Args":["assetTimesCount", "03a471b6c3d2...", "view"]}'</code></p>
</li>
<li>SDK(go):
  <code>go
  assetHash := "03a471b6c3d2..."
  countType := "view"
  req := channel.Request{ChaincodeID: "mych", Fcn: "assetTimesCount", Args: [][]byte{[]byte(assetHash), []byte(countType)}}
  respone, err := t.Client.Execute(req)</code></li>
</ul>
<h3 id="_9">资源冻结</h3>
<ul>
<li>
<p>函数调用: <strong>assetFreeze</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>为用户提供资源冻结的接口. 可一次性冻结一个或多个资源. 被冻结的资源不会移除, 只是不允许再被购买.</p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>assetHashs</td>
<td>[]string</td>
<td>要冻结的资源哈希</td>
<td>不可空</td>
</tr>
</tbody>
</table>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode invoke -C mych -n example -c '{"Args":["assetFreeze", "03a471b6c3d2...", "26b902c813a1..."]}'</code></li>
<li>SDK(go):
  <code>go
  assetHash1 := "03a471b6c3d2..."
  assetHash2 := "26b902c813a1..."
  req := channel.Request{ChaincodeID: "mych", Fcn: "assetFreeze", Args: [][]byte{[]byte(assetHash1), []byte(assetHash2)}}}
  respone, err := t.Client.Execute(req)</code></li>
</ul>
<h3 id="_10">资源废弃</h3>
<ul>
<li>
<p>函数调用: <strong>assetDiscard</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>为用户提供资源废弃的接口. 可一次性废弃一个或多个资源. 被废弃的资源不会移除, 只是不再可见.</p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>assetHashs</td>
<td>[]string</td>
<td>要废弃的资源哈希</td>
<td>不可空</td>
</tr>
</tbody>
</table>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode invoke -C mych -n example -c '{"Args":["assetDiscard", "03a471b6c3d2...", "26b902c813a1..."]}'</code></li>
<li>SDK(go):
  <code>go
  assetHash1 := "03a471b6c3d2..."
  assetHash2 := "26b902c813a1..."
  req := channel.Request{ChaincodeID: "mych", Fcn: "assetDiscard", Args: [][]byte{[]byte(assetHash1), []byte(assetHash2)}}}
  respone, err := t.Client.Execute(req)</code></li>
</ul>
<h3 id="_11">积分充值</h3>
<ul>
<li>
<p>函数调用: <strong>balanceRecharge</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>为用户提供积分充值接口. </p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>userid</td>
<td>string</td>
<td>用户ID, 形如User1@org1.example.com</td>
<td>不可空</td>
</tr>
<tr>
<td>value</td>
<td>string</td>
<td>需要充值的积分值, 不允许为负</td>
<td>不可空</td>
</tr>
</tbody>
</table>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode invoke -C mych -n example -c '{"Args":["balanceRecharge", "User1@org1.example.com", "100"]}'</code></li>
<li>SDK(go):
  <code>go
  userid := "User1@org1.example.com"
  value := "100"
  req := channel.Request{ChaincodeID: "mych", Fcn: "balanceRecharge", Args: [][]byte{[]byte(userid), []byte(value)}}
  respone, err := t.Client.Execute(req)</code></li>
</ul>
<h3 id="_12">积分转让</h3>
<ul>
<li>
<p>函数调用: <strong>balanceTransfer</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>为用户提供积分转让接口. </p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>userid</td>
<td>string</td>
<td>需转让的用户ID, 形如User1@org1.example.com</td>
<td>不可空</td>
</tr>
<tr>
<td>value</td>
<td>string</td>
<td>需转让的积分值, 不允许为负</td>
<td>不可空</td>
</tr>
</tbody>
</table>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode invoke -C mych -n example -c '{"Args":["balanceTransfer", "User1@org1.example.com", "100"]}'</code></li>
<li>SDK(go):
  <code>go
  userid := "User1@org1.example.com"
  value := "100"
  req := channel.Request{ChaincodeID: "mych", Fcn: "balanceTransfer", Args: [][]byte{[]byte(userid), []byte(value)}}
  respone, err := t.Client.Execute(req)</code></li>
</ul>
<h3 id="_13">资源评论</h3>
<ul>
<li>
<p>函数调用: <strong>commentAdd</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>为用户提供资源评论接口. </p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>commentHash</td>
<td>string</td>
<td>评论哈希</td>
<td>不可空</td>
</tr>
<tr>
<td>assetHash</td>
<td>string</td>
<td>评论的资源哈希</td>
<td>不可空</td>
</tr>
<tr>
<td>commentFloor</td>
<td>string</td>
<td>评论楼层</td>
<td>可空</td>
</tr>
<tr>
<td>assetGrade</td>
<td>string</td>
<td>对资源的评分</td>
<td>可空</td>
</tr>
</tbody>
</table>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode invoke -C mych -n example -c '{"Args":["commentAdd", "32b71e46a5c8...", "03a471b6c3d2...", "", ""]}'</code></li>
<li>SDK(go):
  <code>go
  commentHash := "32b71e46a5c8..."
  assetHash := "03a471b6c3d2..."
  commentFloor := ""
  assetGrade := ""
  req := channel.Request{ChaincodeID: "mych", Fcn: "commentAdd", Args: [][]byte{[]byte(commentHash), []byte(assetHash), []byte(commentFloor), []byte(assetGrade)}}
  respone, err := t.Client.Execute(req)</code></li>
</ul>
<h3 id="_14">评论赞成/反对</h3>
<ul>
<li>
<p>函数调用: <strong>commentRateSet</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>为用户提供资源评论的赞成和反对接口. </p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>commentHash</td>
<td>string</td>
<td>评论哈希</td>
<td>不可空</td>
</tr>
<tr>
<td>ptype</td>
<td>string</td>
<td>agree: 赞成; against: 反对</td>
<td>不可空</td>
</tr>
</tbody>
</table>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode invoke -C mych -n example -c '{"Args":["commentRateSet", "32b71e46a5c8...", "agree"]}'</code></li>
<li>SDK(go):
  <code>go
  commentHash := "32b71e46a5c8..."
  ptype := "agree"
  req := channel.Request{ChaincodeID: "mych", Fcn: "commentRateSet", Args: [][]byte{[]byte(commentHash), []byte(ptype)}}
  respone, err := t.Client.Execute(req)</code></li>
</ul>
<h3 id="_15">评论废弃</h3>
<ul>
<li>
<p>函数调用: <strong>commentDiscard</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>为用户提供资源评论废弃接口. 可一次性废弃一个或多个评论. 被废弃的评论不会删除, 只是不可见.</p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>commentHashs</td>
<td>[]string</td>
<td>评论哈希</td>
<td>不可空</td>
</tr>
</tbody>
</table>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode invoke -C mych -n example -c '{"Args":["commentRateSet", "32b71e46a5c8...", "03a471b6c3d2..."]}'</code></li>
<li>SDK(go):
  <code>go
  commentHash1 := "32b71e46a5c8..."
  commentHash2 := "03a471b6c3d2..."
  req := channel.Request{ChaincodeID: "mych", Fcn: "commentDiscard", Args: [][]byte{[]byte(commentHash1), []byte(commentHash2)}}
  respone, err := t.Client.Execute(req)</code></li>
</ul>
<h3 id="_16">资源查询</h3>
<ul>
<li>
<p>函数调用: <strong>assetQuery</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>根据资源哈希提供资源查询接口. 可以一次查询一个或多个资源哈希.</p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>assetHashs</td>
<td>[]string</td>
<td>要查询的资源哈希</td>
<td>不可空</td>
</tr>
</tbody>
</table>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode query -C mych -n example -c '{"Args":["assetQuery", "03a471b6c3d2...", "26b902c813a1..."]}'</code></li>
<li>SDK(go):
  <code>go
  assetHash1 := "03a471b6c3d2..."
  assetHash2 := "26b902c813a1..."
  req := channel.Request{ChaincodeID: "mych", Fcn: "assetQuery", Args: [][]byte{[]byte(assetHash1), []byte(assetHash2)}}
  respone, err := t.Client.Query(req)</code></li>
</ul>
<h3 id="_17">资源评论查询</h3>
<ul>
<li>
<p>函数调用: <strong>assetCommentQuery</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>根据资源哈希提供资源评论查询接口.</p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>assetHash</td>
<td>string</td>
<td>要查询的资源哈希</td>
<td>不可空</td>
</tr>
<tr>
<td>pageSize</td>
<td>string</td>
<td>分页页号</td>
<td>可选</td>
</tr>
<tr>
<td>bookmark</td>
<td>string</td>
<td>分页标记</td>
<td>可选</td>
</tr>
</tbody>
</table>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode query -C mych -n example -c '{"Args":["assetCommentQuery", "03a471b6c3d2..."]}'</code></li>
<li>SDK(go):
  <code>go
  assetHash := "03a471b6c3d2..."
  req := channel.Request{ChaincodeID: "mych", Fcn: "assetCommentQuery", Args: [][]byte{[]byte(assetHash)}}
  respone, err := t.Client.Query(req)</code></li>
</ul>
<h3 id="_18">用户评论查询</h3>
<ul>
<li>
<p>函数调用: <strong>userCommentQuery</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>为用户提供其所有资源评论查询接口.</p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>assetHash</td>
<td>string</td>
<td>要查询的资源哈希</td>
<td>不可空</td>
</tr>
<tr>
<td>pageSize</td>
<td>string</td>
<td>分页页号</td>
<td>可选</td>
</tr>
<tr>
<td>bookmark</td>
<td>string</td>
<td>分页标记</td>
<td>可选</td>
</tr>
</tbody>
</table>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode query -C mych -n example -c '{"Args":["userCommentQuery"]}'</code></li>
<li>SDK(go):
  <code>go
  req := channel.Request{ChaincodeID: "mych", Fcn: "userCommentQuery", Args: nil}
  respone, err := t.Client.Query(req)</code></li>
</ul>
<h3 id="_19">评论查询</h3>
<ul>
<li>
<p>函数调用: <strong>commentQuery</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>资源评论查询和用户评论查询只能查询到评论哈希, 需要使用评论哈希通过评论查询获取评论具体信息. 可一次查询一个或多个评论信息.</p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>commentHashs</td>
<td>[]string</td>
<td>要查询的评论哈希</td>
<td>不可空</td>
</tr>
<tr>
<td>pageSize</td>
<td>string</td>
<td>分页页号</td>
<td>可选</td>
</tr>
<tr>
<td>bookmark</td>
<td>string</td>
<td>分页标记</td>
<td>可选</td>
</tr>
</tbody>
</table>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode query -C mych -n example -c '{"Args":["commentQuery", "03a471b6c3d2...", "26b902c813a1..."]}'</code></li>
<li>SDK(go):
  <code>go
  commentHash1 := "03a471b6c3d2..."
  commentHash2 := "26b902c813a1..."
  req := channel.Request{ChaincodeID: "mych", Fcn: "commentQuery", Args: [][]byte{[]byte(commentHash1), []byte(commentHash2)}}
  respone, err := t.Client.Query(req)</code></li>
</ul>
<h3 id="_20">日志查询</h3>
<ul>
<li>
<p>函数调用: <strong>recordQuery</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>对区块链数据的写操作都将自动记录操作日志, 本函数支持查询指定日志key或者指定用户的操作记录.</p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>recordStart</td>
<td>string</td>
<td>要查询的日志key或者日志范围的Start点</td>
<td>不可空</td>
</tr>
<tr>
<td>recordEnd</td>
<td>string</td>
<td>要查询的日志范围的End点</td>
<td>可选</td>
</tr>
<tr>
<td>pageSize</td>
<td>string</td>
<td>分页页号</td>
<td>可选</td>
</tr>
<tr>
<td>bookmark</td>
<td>string</td>
<td>分页标记</td>
<td>可选</td>
</tr>
</tbody>
</table>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode query -C mych -n example -c '{"Args":["recordQuery", "User1@org1.example.com:1553743949"]}'</code></li>
<li>SDK(go):
  <code>go
  keyStart := "User1@org1.example.com:0"
  keyEnd := "User1@org1.example.com:a"
  req := channel.Request{ChaincodeID: "mych", Fcn: "recordQuery", Args: [][]byte{[]byte(keyStart), []byte(keyEnd)}}
  respone, err := t.Client.Query(req)</code></li>
</ul>
<h3 id="_21">用户日志查询</h3>
<ul>
<li>
<p>函数调用: <strong>userRecordQuery</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>为用户提供其所有操作日志查询接口.</p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>pageSize</td>
<td>string</td>
<td>分页页号</td>
<td>可选</td>
</tr>
<tr>
<td>bookmark</td>
<td>string</td>
<td>分页标记</td>
<td>可选</td>
</tr>
</tbody>
</table>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode query -C mych -n example -c '{"Args":["userRecordQuery"]}'</code></li>
<li>SDK(go):
  <code>go
  req := channel.Request{ChaincodeID: "mych", Fcn: "userRecordQuery", Args: nil}
  respone, err := t.Client.Query(req)</code></li>
</ul>
<h3 id="_22">用户资源查询</h3>
<ul>
<li>
<p>函数调用: <strong>userAssetQuery</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>用于查询与用户相关的所有资源(包括上传和购买). 无需传入参数, 直接以函数调用者作为要查询的用户, 返回用户ID, 资源Hash和关联关系(0:上传, 1:购买).</p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>pageSize</td>
<td>string</td>
<td>分页页号</td>
<td>可选</td>
</tr>
<tr>
<td>bookmark</td>
<td>string</td>
<td>分页标记</td>
<td>可选</td>
</tr>
</tbody>
</table>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode query -C mych -n example -c '{"Args":["userAssetQuery"]}'</code></li>
<li>SDK(go):
  <code>go
  req := channel.Request{ChaincodeID: "mych", Fcn: "userAssetQuery", Args: nil}
  respone, err := t.Client.Query(req)</code></li>
</ul>
<h3 id="_23">积分查询</h3>
<ul>
<li>
<p>函数调用: <strong>balanceQuery</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>查询用户的积分余额. 无需传入参数, 直接将函数调用者作为要查询的用户.</p>
</blockquote>
<ul>
<li>
<p>函数参数:</p>
</li>
<li>
<p>请求示例:</p>
</li>
<li>命令行:
  <code>bash
  peer chaincode query -C mych -n example -c '{"Args":["balanceQuery"]}'</code></li>
<li>SDK(go):
  <code>go
  req := channel.Request{ChaincodeID: "mych", Fcn: "balanceQuery", Args: nil}
  respone, err := t.Client.Query(req)</code></li>
</ul>
<h3 id="_24">用户查询</h3>
<ul>
<li>
<p>函数调用: <strong>userQuery</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>用户仅有ID会入链, 因此用户查询目前仅返回查询时间戳, 用户所属组织的mspid和用户ID. 无需传入参数, 直接将函数调用者作为要查询的用户.</p>
</blockquote>
<ul>
<li>
<p>函数参数:</p>
</li>
<li>
<p>请求示例:</p>
</li>
<li>命令行:
  <code>bash
  peer chaincode query -C mych -n example -c '{"Args":["userQuery"]}'</code></li>
<li>SDK(go):
  <code>go
  req := channel.Request{ChaincodeID: "mych", Fcn: "userQuery", Args: nil}
  respone, err := t.Client.Query(req)</code></li>
</ul>
<h3 id="_25">历史查询</h3>
<ul>
<li>
<p>函数调用: <strong>historyQuery</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>查询指定key的所有变更记录. 支持简单key和复合key. 但一次仅支持查询一个key.</p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>key</td>
<td>[]string</td>
<td>单元素的简单key和多元素的复合key</td>
<td>不可空</td>
</tr>
</tbody>
</table>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode query -C mych -n example -c '{"Args":["historyQuery"], "User1@org1.example.com"}' # 简单key</code></li>
<li>SDK(go):
  <code>go
  keyType := "user~asset"
  userid := "User1@org1.example.com"
  assetHash := "03a471b6c3d2..."
  req := channel.Request{ChaincodeID: "mych", Fcn: "historyQuery", Args: [][]byte{[]byte(keyType), []byte(userid), []byte(assetHash)}}  // 复合key
  respone, err := t.Client.Query(req)</code></li>
</ul>
<h3 id="_26">全查询</h3>
<ul>
<li>
<p>函数调用: <strong>fullQuery</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>查询指定对象类型(user, asset, comment, record)的全部数据.</p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>qtype</td>
<td>string</td>
<td>要查询的对象类型(user, asset, comment, record)</td>
<td>不可空</td>
</tr>
<tr>
<td>pageSize</td>
<td>string</td>
<td>分页页号</td>
<td>可选</td>
</tr>
<tr>
<td>bookmark</td>
<td>string</td>
<td>分页标记</td>
<td>可选</td>
</tr>
</tbody>
</table>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode query -C mych -n example -c '{"Args":["fullQuery", "asset"]}'</code></li>
<li>SDK(go):
  <code>go
  qtype := "asset"
  req := channel.Request{ChaincodeID: "mych", Fcn: "fullQuery", Args: [][]byte{[]byte(qtype)}}
  respone, err := t.Client.Query(req)</code></li>
</ul>
<h3 id="_27">用户资源验证</h3>
<ul>
<li>
<p>函数调用: <strong>userAssetVerify</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<blockquote>
<p>查询用户对指定资源的访问权限. 以函数调用者作为要查询的用户.</p>
</blockquote>
<ul>
<li>函数参数:</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>assetHash</td>
<td>string</td>
<td>要查询的资源哈希</td>
<td>不可空</td>
</tr>
</tbody>
</table>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode query -C mych -n example -c '{"Args":["userAssetVerify", "03a471b6c3d2..."]}'</code></li>
<li>SDK(go):
  <code>go
  assetHash := "03a471b6c3d2..."
  req := channel.Request{ChaincodeID: "mych", Fcn: "userAssetVerify", Args: [][]byte{[]byte(assetHash)}}
  respone, err := t.Client.Query(req)</code></li>
</ul>
<h3 id="_28">富查询</h3>
<ul>
<li>
<p>函数调用: <strong>richQueryResult</strong></p>
</li>
<li>
<p>函数说明:</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>querystr</td>
<td>string</td>
<td>富查询选择器</td>
<td>不可空</td>
</tr>
<tr>
<td>pageSize</td>
<td>string</td>
<td>分页页号</td>
<td>可选</td>
</tr>
<tr>
<td>bookmark</td>
<td>string</td>
<td>分页标记</td>
<td>可选</td>
</tr>
</tbody>
</table>
<blockquote>
<p>针对使用couchdb作为后台状态数据库的Fabric网络, 以couchdb支持的语法格式进行高级查询. 链码暂时直接以传入参数作为选择器, 未支持链码分析传入参数后自动构建选择器.</p>
</blockquote>
<ul>
<li>请求示例:</li>
<li>命令行:
  <code>bash
  peer chaincode query -C mych -n example -c '{"Args":["richQueryResult", "{\"selector\":{\"owner\":\"tom\"}}","3",""]}'</code></li>
<li>SDK(go):
  <code>go
  querystr := "{\"selector\":{\"owner\":\"tom\"}}"
  pageSize := "3"
  bookmark := ""
  req := channel.Request{ChaincodeID: "mych", Fcn: "userAssetVerify", Args: [][]byte{[]byte(querystr), []byte(pageSize), []byte(bookmark)}}
  respone, err := t.Client.Query(req)</code></li>
</ul>
</body></html>