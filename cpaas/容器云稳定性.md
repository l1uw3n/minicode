# 第N章 容器云的稳定性

容器云是一种平台级基础设施, 作为大规模业务应用的载体, 其稳定性关系到托管业务的可用性,  保证平台稳定的重要性是不言而喻的. 作为容器云的集大成者和行业事实标准, 脱胎于Google企业级容器平台Borg的Kubernetes从诞生之初就引入了稳定性的设计, 无论是对平台本身还是托管的业务应用, Kubernetes都提供了多种保证自身和业务稳定性的机制。

稳定性是一个比较泛化的概念, 诸如兼容性, 性能优化, 可用性, 扩展性等都与之相关. 本章将从API、平台和业务三个维度阐述Kubernetes的稳定性设计. 通过阅读本章, 您将对Kubernetes的API设计, 平台组件、节点、网络与存储的关键点优化策略以及业务容器运行保障机制有更深入的了解, 从而对保证集群和业务系统的稳定可靠运行成竹在胸.

> 性能预估, 平滑升级, 混沌工程

## N.1 API 稳定性设计
Kubernetes是一个灵活强大的生产级别的开源容器编排系统, 与服务器, 网络, 存储等各基础设施和认证授权, 虚拟化, 大数据等各种技术领域有着密切的交互与协作, 同时也在不断吸纳各种其他领域, 迅速地发展壮大. 如何保证这样一个几乎"包罗万象"的系统在不断增加和扩展特性的快速迭代过程中各版本的稳定性和兼容性自然是一个至关重要的课题. 

依托Google生产环境运维经验, 同时凝聚社区最佳创意和实践, Kubernetes社区以其开明的姿态吸引全世界的开发者和爱好者参与其中, 提供诸如讨论版, 视频会议, Meetup社区, 特殊兴趣小组等互动讨论和技术协作渠道, 制定严格而高度自动化的开发, 审核, 迭代规范... Kubernetes社区**重视代码, 重视民主化**的治理方式及其丰富的运作机制为Kubernetes产品本身的的稳定性提供了强有力的保障. 本节不打算讨论社区治理方面的内容, 仅就Kubernetes的API相关内容一窥Kubernetes的稳定性设计.

Kubernetes API是Kubernetes系统的重要组成部分, 组件之间的所有操作和通信以及外部对Kubernetes的调用都是由API Server处理的REST API调用. API的设计对于产品内部通信和外部协作的兼容性, 扩展性和稳定性有着举足轻重的影响.

### N.x API结构与版本

Kubernetes API是通过HTTP提供的编程接口, 以REST风格组织并管理**资源**, 支持通过`POST`, `PUT`, `DELETE`, `GET`等标准的HTTP方法对资源进行增删改查等操作.

#### N.x.1 资源

Kubernetes中所有内容都被抽象为**资源**. 所有资源都可以使用清单文件(manifest file)进行描述, 使用Etcd数据库进行存储并由API Server统一管理.

![Kubernetes v1.17 资源一览](资源.png)

- 资源分为`集群`和`命名空间`两级作用域, 命名空间级资源会在其命名空间删除时被删除. 上图资源类别并不代表其作用域.
- 所有资源在其资源对象模式(清单文件)中都有一个具体的表示形式, 称为Kind. 同一资源的多个对象(实例)可以组成集合.

- 可以通过`kubectl api-resources`命令查看当前Kubernetes环境支持的所有资源的名称, 缩写, api组, 作用域及其对应的Kind.

#### N.x.2 API

Kubernetes API大多数情况下遵循标准的HTTP REST规范, JSON和Protobuf是其主要序列化结构, 资源通过API接口传入API Server最终持久化到Etcd数据库. API是由**API Server**组件提供服务, API Server是Kubernetes的管理中心, 是唯一能够与Etcd数据库交互的组件.

##### N.x.2.1 API群组

Kubernetes API除了提供组织和管理各种资源的接口外, 还包括一些系统层面的接口. 目前API主要分为三种形式:

| 类型             | 描述                                                         | 路径                 | 清单字段示例      |
| ---------------- | ------------------------------------------------------------ | -------------------- | ----------------- |
| Core Group API   | 核心组API, 包括Kubernetes中核心概念相关的API, 如node, pod, service等 | /api/v1              | v1                |
| Named Groups API | 指定组API, 包括各种非核心概念及自定义的API, 如deployment, cronjob等 | /apis/GROUP/VERSION  | apps/v1, batch/v1 |
| System-wide API  | 系统级API, 包括非Kubernetes资源相关的系统级API, 如metrics, healthz等 | /metrics, /healthz等 |                   |

除了系统级API外, Kubernetes基本上是以**API Group(API群组)**的方式组织各种API的, 核心组API并未使用/apis/core/v1路径是历史原因(事实上核心组也成为遗留组). API群组是一组相关的API对象的集合, 使用群组概念能够更方便的管理和扩展API. 结构示意如下:

![api结构](api结构.png)

##### N.x.2.1 API版本

为了在兼容旧版本的同时不断升级新的API, Kubernetes支持多种API版本, 不同的API版本代表其处于不同的稳定性阶段, 低稳定性的API版本在后续的产品升级中可能成为高稳定性的版本. 

API版本规则是通过基于API level选择版本，而不是基于资源和域级别选择，是为了确保API能够描述一个清晰的连续的系统资源和行为的视图，能够控制访问的整个过程和控制实验性API的访问.

![api版本](api版本.png)

API通过这种三级渐进式版本共存与演化策略, 在不断吸纳新的功能特性并给予其足够的孵化空间的同时, 保证了整体API的可用性和稳定性.

- 资源定位三元组

> API Group, API Version和Resource(GVR三元组)就可以唯一确定一个资源的API路径. 如`/apis/rbac.authorization.k8s.io/v1beta1/clusterroles`. 
> 
> 对于命名空间级资源则需要额外包含具体命名空间(否则将请求所有命名空间下相应资源), 如`/apis/apps/v1/namespaces/kube-system/deployments`. 
>
> 对应到资源对象模式(清单文件)三元组则为API Group, API Version和Kind(GVK), 相应字段为`apiVersion`和`kind`, 如`{"apiVersion": "app/v1", "kind": "Deployment"}`.

- Kubernetes组件默认启用加密通信, 并需要请求者提供凭证, 为了更方便地请求API, 可以开启代理访问.

  ```bash
  kubectl proxy --port=8888   # 开启代理访问
  curl http://localhost:8888/api/pods/ # kubectl代理会自动使用默认凭证路径(/etc/kubernetes/ssl/)下的凭证文件(kube-proxy.xx)
  ```

- 可以通过`kubectl api-versions`命令查看当前Kubernetes环境启用的所有API群组及其版本.

##### N.x.2.2 数据持久化与无损转换

但用户向Kubernetes发起资源构建请求时只提供了一个资源清单文件(如deployment.yaml), 但事实上Kubernetes基于可用性和稳定性的考虑, 却能够支持同时使用不同稳定性的API版本访问同一资源, 返回不同版本的资源数据. 这一灵活的特性有赖于API Server的资源数据无损耗转换机制.

### N.x 自定义资源与API

## N.x 平台优化 - 关键点指南

### N.x 组件优化

### N.x 节点优化

### N.x 网络优化

### N.x 存储优化

## N.x 业务稳定性保障

### N.x 健康检查

### N.x 服务质量

### N.x 弹性伸缩

### N.x 变更策略



## Link

https://www.cnblogs.com/hwpaas/p/9561406.html

https://www.cnblogs.com/hwpaas/p/9561526.html

https://www.cnblogs.com/hwpaas/p/9561683.html

http://book.itmuch.com/

https://www.google.com/search?newwindow=1&biw=1698&bih=832&sxsrf=ACYBGNRwXML9HSRIBKSTwzgN9FlS0Nj70A%3A1579002072618&ei=2KgdXp-oJZf4-gSUpLgQ&q=turbine.aggregator.clusterConfig&oq=turbine.aggregator.clusterConfig&gs_l=psy-ab.3..0i203.754.754..2123...0.0..0.1106.1106.7-1......0....1..gws-wiz.jrKWlsBb1n0&ved=0ahUKEwif9IyNgYPnAhUXvJ4KHRQSDgI4ChDh1QMICw&uact=5

https://stackoverflow.com/questions/40720979/how-to-access-kubernetes-api-when-using-minkube

https://www.cnblogs.com/chenqionghe/p/11718365.html

https://cloud.tencent.com/developer/article/1482739

https://juejin.im/post/5b460f506fb9a04fcf59bf73

https://access.redhat.com/documentation/zh-cn/openshift_container_platform/4.2/html/scalability_and_performance/planning-your-environment-according-to-object-limits

https://www.cnblogs.com/goldsunshine/p/10701242.html

https://juejin.im/post/5de1f2c4e51d455c0172ba7e

https://ggaaooppeenngg.github.io/zh-CN/2017/11/05/Kubernetes-API-%E5%88%86%E6%9E%90/

https://ggaaooppeenngg.github.io/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/

